# Scene 2 Implementation Plan

<SCENE_VISION_STORYBOARD_PLAN>
[SCENE_VISION]
1.  **Scene Overview**:
    - In this scene, we aim to explain the concept of the derivative by discussing the slope of a function. We'll visualize how to calculate the slope using two points on a function's graph, building on the function's definition from Scene 1.
    - **Visual learning objectives for viewers:** We will use `Axes` to represent the function graph, `Dot` objects to mark the two points, and `Line` to illustrate the connecting line between these points. `MathTex` will be employed to display the rise over run values clearly.
    - The visuals will support learning by providing a clear representation of the slope concept. The `Axes` will be the background, with `Dot` objects representing the points clearly on the graph. The `Line` connecting the two points will help visualize the slope calculation, and using `MathTex` for slope annotations will reinforce the mathematical concepts.
    - Key concepts to emphasize visually include the slope formula (rise/run) using `MathTex`, the two points as `Dot` objects, and the connecting `Line`. We will ensure a minimum spacing of 0.3 units between all elements and adhere to the safe area margins.

[STORYBOARD]
1.  **Visual Flow & Pacing (Manim Animation Sequence)**:
    - Start with the `Axes` being created with `Create(axes)` animation, ensuring it is centered and occupies the safe area margins.
    - **Sub-scene 1: Function Graph**
        - **Visual Element:** `Axes` object representing the function graph.
        - **Animation Sequence:** 
            - `Create(axes)` with a run time of `2`. 
            - Wait for `1` second for clarity.
    
    - **Sub-scene 2: Points on the Graph**
        - **Visual Element:** Two `Dot` objects representing points on the graph at coordinates (1, f(1)) and (3, f(3)).
        - **Animation Sequence:**
            - Create the first point `point_a = Dot(axes.c2p(1, function(1)), color=RED)`.
            - `Create(point_a)` with a run time of `1`.
            - Wait `0.5` seconds.
            - Create the second point `point_b = Dot(axes.c2p(3, function(3)), color=RED)`.
            - `Create(point_b)` with a run time of `1`.
            - Wait `0.5` seconds.

    - **Sub-scene 3: Connecting Line**
        - **Visual Element:** A `Line` object connecting the two points.
        - **Animation Sequence:**
            - Create the line `connecting_line = Line(point_a.get_center(), point_b.get_center())`.
            - `Create(connecting_line)` with a run time of `1`.
            - Wait for `1` second to allow viewers to absorb the connection visually.

    - **Sub-scene 4: Rise over Run Annotations**
        - **Visual Element:** `MathTex` objects for rise and run annotations.
        - **Animation Sequence:**
            - Create `rise = MathTex(r"\text{Rise} = f(3) - f(1)").next_to(connecting_line, UP, buff=0.3)`.
            - `Write(rise)` with a run time of `1`.
            - Create `run = MathTex(r"\text{Run} = 3 - 1").next_to(rise, DOWN, buff=0.3)`.
            - `Write(run)` with a run time of `1`.
            - Wait for `1` second to emphasize the rise/run relationship visually.

    - **Sub-scene 5: Final Slope Annotation**
        - **Visual Element:** Final slope formula as `MathTex`.
        - **Animation Sequence:**
            - Create `slope = MathTex(r"\text{Slope} = \frac{\text{Rise}}{\text{Run}}").to_edge(UP)`.
            - `Write(slope)` with a run time of `1`.
            - Wait `2` seconds to finalize the scene and allow viewers to absorb the information.

    - Ensure all elements respect the safe area margins and maintain a minimum spacing of 0.3 units between each other and the scene edges throughout the animations.

</SCENE_VISION_STORYBOARD_PLAN>

<SCENE_TECHNICAL_IMPLEMENTATION_PLAN>
0. **Dependencies**:
    - **Manim API Version**: Latest stable version (e.g., 0.15.0).
    - **Allowed Imports**: `from manim import *`, `import numpy as np`.

1. **Manim Object Selection & Configuration (Text and Shapes)**:
    - **Axes**: 
        - `axes = Axes(x_range=[0, 4, 1], y_range=[0, 5, 1], axis_config={"color": BLUE})`
    - **Points (Dots)**:
        - `point_a = Dot(axes.c2p(1, function(1)), color=RED)` 
        - `point_b = Dot(axes.c2p(3, function(3)), color=RED)`
    - **Connecting Line**:
        - `connecting_line = Line(point_a.get_center(), point_b.get_center(), color=YELLOW)`
    - **Rise and Run Annotations**:
        - `rise = MathTex(r"\text{Rise} = f(3) - f(1)").scale(0.7)`
        - `run = MathTex(r"\text{Run} = 3 - 1").scale(0.7)`
    - **Final Slope Annotation**:
        - `slope = MathTex(r"\text{Slope} = \frac{\text{Rise}}{\text{Run}}").scale(0.7)`

    - **Text Considerations**:
        - All `MathTex` objects will be used for mathematical expressions. The font size for annotations will be set to 24.
        - Confirm all objects begin within the safe area (0.5 units from all edges) and maintain at least 0.3 units spacing to avoid overlaps.

2. **VGroup Structure & Hierarchy**:
    - Group annotations for clarity:
        - `rise_run_group = VGroup(rise, run)` will hold both rise and run annotations.
        - `slope_group = VGroup(slope)` will hold the final slope annotation.
    - Ensure internal spacing of at least 0.3 units within each group.

3. **Spatial Positioning Strategy**:
    - **Axes**: Centered using the default positioning at ORIGIN.
    - **Point A**:
        - Positioned relative to the axes: `point_a.next_to(axes, UP, buff=0.5)`
    - **Point B**:
        - Positioned relative to the axes: `point_b.next_to(point_a, RIGHT, buff=0.5)`
    - **Connecting Line**: 
        - Created as a direct connection between the centers of `point_a` and `point_b`.
    - **Rise Annotation**: 
        - Positioned above the connecting line: `rise.next_to(connecting_line, UP, buff=0.3)`
    - **Run Annotation**: 
        - Positioned below the rise annotation: `run.next_to(rise, DOWN, buff=0.3)`
    - **Slope Annotation**: 
        - Positioned at the top of the scene, aligned with the center: `slope.to_edge(UP, buff=0.5)`

4. **Animation Methods & Object Lifecycle Management**:
    - Animation Sequence:
        - `self.play(Create(axes), run_time=2)`
        - `self.wait(1)`
        - `self.play(Create(point_a), run_time=1)`
        - `self.wait(0.5)`
        - `self.play(Create(point_b), run_time=1)`
        - `self.wait(0.5)`
        - `self.play(Create(connecting_line), run_time=1)`
        - `self.wait(1)`
        - `self.play(Write(rise), run_time=1)`
        - `self.play(Write(run), run_time=1)`
        - `self.wait(1)`
        - `self.play(Write(slope), run_time=1)`
        - `self.wait(2)`

5. **Code Structure & Reusability**:
    - Organize the overall code structure into logical sections: dependencies, object definitions, layout stages, and the main `construct` method.
    - Include inline comments to document the rationale for configuration choices. For example:
        ```python
        # Create axes to represent the function graph
        axes = Axes(...)
        ```

***Mandatory Safety Checks***:
    - **Safe Area Enforcement**: All objects, including text bounding boxes, must remain within 0.5 unit margins.
    - **Minimum Spacing Validation**: Confirm a minimum of 0.3 units spacing between every pair of objects.
    - **Transition Buffers**: Use explicit `Wait()` calls to separate animation steps and sub-scenes.
</SCENE_TECHNICAL_IMPLEMENTATION_PLAN>

litellm.Timeout: APITimeoutError - Request timed out. Error_str: Request timed out.

